# Copyright 2015 Google Inc. All Rights Reserved.

"""Fingerprinting code for the Ruby runtime."""

import os
import re
import subprocess
import textwrap

from googlecloudsdk.core import exceptions
from googlecloudsdk.core import log
from googlecloudsdk.core.console import console_io

from googlecloudsdk.appengine.lib import fingerprinting
from googlecloudsdk.appengine.lib.images import config


# Keep these up to date.
BUNDLER_VERSION = '1.10.6'
FOREMAN_VERSION = '0.78.0'

# Mapping from gems to libraries they expect.
GEM_PACKAGES = {
    'rgeo': ['libgeos-dev', 'libproj-dev']
}

APP_YAML_CONTENTS = textwrap.dedent("""\
    runtime: ruby
    vm: true
    api_version: 1
    entrypoint: {0}
    """)
DOCKERIGNORE_CONTENTS = textwrap.dedent("""\
    .dockerignore
    Dockerfile
    .git
    .hg
    .svn
    """)

DOCKERFILE_HEADER = textwrap.dedent("""\
    # This Dockerfile for a Ruby application was generated by gcloud.

    # The base Dockerfile installs:
    # * A number of packages needed by the Ruby runtime and by gems
    #   commonly used in Ruby web apps (such as libsqlite3)
    # * A recent version of NodeJS
    # * A recent version of the standard Ruby runtime to use by default
    # * The bundler and foreman gems
    FROM gcr.io/google_appengine/ruby
    """)
DOCKERFILE_DEFAULT_INTERPRETER = textwrap.dedent("""\
    # This Dockerfile uses the default Ruby interpreter installed and
    # specified by the base image.
    # If you want to use a specific ruby interpreter, provide a
    # .ruby-version file, then delete this Dockerfile and re-run
    # "gcloud app gen-config" to recreate it.
    """)
DOCKERFILE_CUSTOM_INTERPRETER = textwrap.dedent("""\
    # Install ruby {{0}} if not already preinstalled by the base image
    RUN rbenv install -s {{0}} && \\
        rbenv global {{0}} && \\
        gem install -q --no-rdoc --no-ri bundler --version {0} && \\
        gem install -q --no-rdoc --no-ri foreman --version {1}
    ENV RBENV_VERSION {{0}}
    """.format(BUNDLER_VERSION, FOREMAN_VERSION))
DOCKERFILE_MORE_PACKAGES = textwrap.dedent("""\
    # Install additional package dependencies needed by installed gems.
    # Feel free to add any more needed by your gems.
    RUN apt-get update -y && \\
        apt-get install -y -q --no-install-recommends \\
            {0} \\
        && apt-get clean && rm /var/lib/apt/lists/*_*
    """)
DOCKERFILE_NO_MORE_PACKAGES = textwrap.dedent("""\
    # If you need to install any additional packages needed by your gems,
    # insert an "apt-get update" and "apt-get install" here.
    """)
DOCKERFILE_GEM_INSTALL = textwrap.dedent("""\
    # Install required gems.
    COPY Gemfile Gemfile.lock /app/
    RUN bundle install && rbenv rehash
    """)
DOCKERFILE_ENTRYPOINT = textwrap.dedent("""\
    # Start application on port 8080.
    COPY . /app/
    ENTRYPOINT {0}
    """)

ENTRYPOINT_FOREMAN = 'foreman start web -p 8080'
ENTRYPOINT_PUMA = 'bundle exec puma -p 8080 -e production'
ENTRYPOINT_UNICORN = 'bundle exec unicorn -p 8080 -E production'
ENTRYPOINT_RACKUP = 'bundle exec rackup -p 8080 -E production /app/config.ru'


class RubyConfigurator(fingerprinting.Configurator):
  """Generates configuration for a Ruby app."""

  def __init__(self, path, deploy, ruby_version, entrypoint, packages):
    """Constructor.

    Args:
      path: (str) Root path of the source tree.
      deploy: (bool) True if this is being driven from the "deploy" command. In
        this case, we do not generate app.yaml and we make the code cleanup
        whatever we generate.
      ruby_version: (str) The ruby interpreter in rbenv format
      entrypoint: (str) The entrypoint command
      packages: ([str, ...]) A set of packages to install
    """

    self.root = path
    self.deploy = deploy
    self.ruby_version = ruby_version
    self.entrypoint = entrypoint
    self.packages = packages

    # Write messages to the console or to the log depending on whether we're
    # doing a "deploy."
    if deploy:
      self.notify = log.info
    else:
      self.notify = log.status.Print

  def GenerateConfigs(self):
    """Generates all config files for the module.

    Returns:
      (fingerprinting.Cleaner) A cleaner populated with the generated files
    """

    cleaner = fingerprinting.Cleaner()

    self._GenerateDockerfile(cleaner)
    if not self.deploy:
      self._GenerateAppYaml(cleaner)
    self._GenerateDockerignore(cleaner)

    if not cleaner.HasFiles():
      self.notify('All config files already exist, not generating anything.')

    return cleaner

  def _GenerateAppYaml(self, cleaner):
    """Generates an app.yaml file appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    app_yaml = os.path.join(self.root, 'app.yaml')
    if not os.path.exists(app_yaml):
      self.notify('Saving [app.yaml] to [{0}].'.format(self.root))
      with open(app_yaml, 'w') as f:
        f.write(APP_YAML_CONTENTS.format(self.entrypoint))
      cleaner.Add(app_yaml)

  def _GenerateDockerfile(self, cleaner):
    """Generates a Dockerfile appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    dockerfile = os.path.join(self.root, config.DOCKERFILE)
    if not os.path.exists(dockerfile):
      self.notify('Saving [{0}] to [{0}].'.format(config.DOCKERFILE, self.root))

      dockerfile_content = [DOCKERFILE_HEADER]
      if self.ruby_version:
        dockerfile_content.append(
            DOCKERFILE_CUSTOM_INTERPRETER.format(self.ruby_version))
      else:
        dockerfile_content.append(DOCKERFILE_DEFAULT_INTERPRETER)
      if self.packages:
        dockerfile_content.append(
            DOCKERFILE_MORE_PACKAGES.format(' '.join(self.packages)))
      else:
        dockerfile_content.append(DOCKERFILE_NO_MORE_PACKAGES)
      dockerfile_content.append(DOCKERFILE_GEM_INSTALL)
      dockerfile_content.append(
          DOCKERFILE_ENTRYPOINT.format(self.entrypoint))

      with open(dockerfile, 'a') as f:
        f.write('\n'.join(dockerfile_content))

      cleaner.Add(dockerfile)

  def _GenerateDockerignore(self, cleaner):
    """Generates a .dockerignore file appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    dockerignore = os.path.join(self.root, '.dockerignore')
    if not os.path.exists(dockerignore):
      self.notify('Saving [.dockerignore] to [{0}].'.format(self.root))
      with open(dockerignore, 'w') as f:
        f.write(DOCKERIGNORE_CONTENTS)
      cleaner.Add(dockerignore)


def Fingerprint(path, params):
  """Check for a Ruby app.

  Args:
    path: (str) Application path.
    params: (fingerprinting.Params) Parameters passed through to the
      fingerprinters.

  Returns:
    (RubyConfigurator or None) Returns a configurator if the path contains a
    Ruby app, or None if not.
  """
  appinfo = params.appinfo
  entrypoint = None
  is_explicit_runtime = False
  if appinfo:
    if appinfo.GetEffectiveRuntime() != 'ruby':
      return None
    is_explicit_runtime = True

    if appinfo.entrypoint:
      entrypoint = appinfo.entrypoint

  log.info('Checking for Ruby.')

  gemfile_path = os.path.join(path, 'Gemfile')
  if not os.path.isfile(gemfile_path):
    if is_explicit_runtime:
      raise exceptions.Error('Gemfile required for Ruby runtime')
    else:
      return None

  _CheckFiles(path)

  gems = _DetectGems()
  ruby_version = _DetectRubyInterpreter(path)
  packages = _DetectNeededPackages(gems)

  if not entrypoint:
    default_entrypoint = _DetectDefaultEntrypoint(path, gems)
    entrypoint = _ChooseEntrypoint(default_entrypoint, appinfo)
    if not entrypoint:
      return None

  return RubyConfigurator(path, params.deploy, ruby_version, entrypoint,
                          packages)


def _CheckFiles(path):
  """Runs some sanity checks on the application.

  Args:
    path: (str) Application path.

  Raises:
    exceptions.Error: The application is recognized as a Ruby app but
    malformed in some way.
  """
  gemfile_lock_path = os.path.join(path, 'Gemfile.lock')
  if not os.path.isfile(gemfile_lock_path):
    raise exceptions.Error('Gemfile present but Gemfile.lock not found.')

  if not _SubprocessSucceeds('bundle check'):
    raise exceptions.Error('Your bundle is not up-to-date. '
                           "Install missing gems with 'bundle install'.")

  # TODO(user): Check that the Gemfile.lock is up to date


def _DetectRubyInterpreter(path):
  """Determines the ruby interpreter and version expected by this application.

  Args:
    path: (str) Application path.

  Returns:
    (str) The interpreter version in rbenv (.ruby-version) format
  """
  ruby_info = _RunSubprocess('bundle platform --ruby')
  if not re.match('^No ', ruby_info):
    match = re.match(r'^ruby (\d+\.\d+(\.\d+(-p\d+)?)?)', ruby_info)
    if match:
      ruby_version = match.group(1)
      log.info(
          'Using MRI {0} as requested in the Gemfile.'.format(ruby_version))
      return ruby_version
    # TODO(user): Identify other interpreters
    log.warning('Unrecognized platform in Gemfile: [{0}]'.format(ruby_info))

  ruby_version = _ReadFile(path, '.ruby-version')
  if ruby_version:
    ruby_version = ruby_version.strip()
    log.info(
        'Using ruby {0} as requested in the .ruby-version'.format(ruby_version))
    return ruby_version

  # Default to the latest MRI.
  log.warning('No ruby version specified. Using a default. '
              'We recommend that you specify a ruby interpreter to use, '
              'either by creating a .ruby-version file or by adding a '
              '"ruby" declaration to your Gemfile.')
  return None


def _DetectGems():
  """Returns a list of gems requested by this application.

  Returns:
    ([str, ...]) A list of gem names.
  """
  gems = []
  for line in _RunSubprocess('bundle list').splitlines():
    match = re.match(r'\s*\*\s+(\S+)\s+\(', line)
    if match:
      gems.append(match.group(1))
  return gems


def _DetectDefaultEntrypoint(path, gems):
  """Returns the app server expected by this application.

  Args:
    path: (str) Application path.
    gems: ([str, ...]) A list of gems used by this application.

  Returns:
    (str) The default entrypoint command.
  """
  procfile_path = os.path.join(path, 'Procfile')
  if os.path.isfile(procfile_path):
    return ENTRYPOINT_FOREMAN

  if 'puma' in gems:
    return ENTRYPOINT_PUMA
  elif 'unicorn' in gems:
    return ENTRYPOINT_UNICORN

  return ENTRYPOINT_RACKUP


def _ChooseEntrypoint(default_entrypoint, appinfo):
  """Prompt the user for an entrypoint.

  Args:
    default_entrypoint: (str) Default entrypoint determined from the app.
    appinfo: (apphosting.api.appinfo.AppInfoExternal or None) The parsed
      app.yaml file for the module if it exists.

  Returns:
    (str) The actual entrypoint to use.
  """
  if console_io.IsInteractive():
    prompt = ('Please enter the command to run this ruby app in production:\n'
              '[ {0} ] ')
    entrypoint = console_io.PromptResponse(prompt.format(default_entrypoint))
    entrypoint = entrypoint.strip()
    if not entrypoint:
      entrypoint = default_entrypoint
    if appinfo:
      # We've got an entrypoint and the user had an app.yaml that didn't
      # specify it.
      # TODO(user): Offer to edit the user's app.yaml
      msg = ('To avoid being asked for an entrypoint in the future, please '
             'add it to your app.yaml. e.g.\n'
             '  entrypoint: {0}')
      log.status.Print(msg.format(entrypoint))
    return entrypoint
  else:
    msg = ('Using a default entrypoint of [{0}]. If this is incorrect, please '
           'create an app.yaml file with an "entrypoint" field specifying the '
           'command to run the app in production.')
    log.info(msg.format(default_entrypoint))
    return default_entrypoint


def _DetectNeededPackages(gems):
  """Determines additional apt-get packages required by the given gems.

  Args:
    gems: ([str, ...]) A list of gems used by this application.

  Returns:
    ([str, ...]) A sorted list of strings indicating packages to install
  """
  package_set = set()
  for gem in gems:
    if gem in GEM_PACKAGES:
      package_set.update(GEM_PACKAGES[gem])
  packages = list(package_set)
  packages.sort()
  return packages


def _RunSubprocess(cmd):
  p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  if p.wait() != 0:
    raise exceptions.Error('Unable to run script: [{0}]'.format(cmd))
  return p.stdout.read()


def _SubprocessSucceeds(cmd):
  p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  return p.wait() == 0


def _ReadFile(root, filename, required=False):
  path = os.path.join(root, filename)
  if not os.path.isfile(path):
    if required:
      raise exceptions.Error(
          'Could not find required file: [{0}]'.format(filename))
    return None
  with open(path) as f:
    return f.read()
